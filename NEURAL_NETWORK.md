# Як працює нейронна мережа для прогнозування криптовалют

## Огляд системи

Система використовує **LSTM (Long Short-Term Memory)** нейронну мережу для прогнозування руху цін криптовалют. LSTM - це тип рекурентної нейронної мережі, яка добре підходить для аналізу часових рядів.

## Архітектура нейронної мережі

### Структура моделі

```python
Sequential([
    Input(shape=(30, 5)),           # Вхідний шар: 30 часових точок × 5 ознак
    LSTM(units=128, return_sequences=False),  # LSTM шар з 128 нейронами
    Dropout(0.2),                   # Dropout для запобігання перенавчанню
    Dense(1, activation='sigmoid')  # Вихідний шар: бінарна класифікація
])
```

### Пояснення шарів:

1. **Input Layer (Вхідний шар)**
   - Приймає послідовність з 30 часових точок
   - Кожна точка має 5 ознак: `open`, `high`, `low`, `close`, `volume`
   - Форма: `(batch_size, 30, 5)`

2. **LSTM Layer (LSTM шар)**
   - 128 нейронів (units=128)
   - Аналізує послідовність даних і виявляє патерни
   - `return_sequences=False` - повертає тільки останній вихід
   - Зберігає довготривалу пам'ять про попередні дані

3. **Dropout Layer (Dropout шар)**
   - Випадково вимикає 20% нейронів під час навчання
   - Запобігає перенавчанню (overfitting)
   - Покращує узагальнення моделі

4. **Dense Layer (Щільний шар)**
   - 1 нейрон з sigmoid активацією
   - Виводить значення від 0 до 1
   - Інтерпретація: ймовірність зростання ціни

## Процес роботи

### 1. Підготовка даних

```python
# Вхідні дані з Binance API
prices_data = [
    {
        "timestamp": 1234567890,
        "open": 50000.0,
        "high": 51000.0,
        "low": 49500.0,
        "close": 50500.0,
        "volume": 1000000.0,
        "trades": 5000
    },
    # ... ще 29+ записів
]
```

#### Кроки підготовки:

1. **Створення DataFrame**
   ```python
   df = pd.DataFrame(prices_data)
   ```

2. **Вибір ознак**
   ```python
   feature_cols = ['open', 'high', 'low', 'close', 'volume']
   data = df[feature_cols]
   ```

3. **Нормалізація (MinMaxScaler)**
   ```python
   scaler = MinMaxScaler()
   scaled_data = scaler.fit_transform(data)
   # Перетворює всі значення в діапазон [0, 1]
   ```

4. **Створення вікна (window)**
   ```python
   X = scaled_data[-30:].reshape(1, 30, 5)
   # Беремо останні 30 точок даних
   # Форма: (1 приклад, 30 часових кроків, 5 ознак)
   ```

### 2. Прогнозування

```python
# Модель обробляє дані
prediction = model.predict(X)
# Результат: число від 0 до 1
# Наприклад: 0.65 означає 65% ймовірність зростання
```

### 3. Інтерпретація результату

```python
predicted_value = 0.65  # Приклад

# Інтерпретація:
if predicted_value > 0.5:
    # Ціна, ймовірно, зросте
    direction = "UP"
else:
    # Ціна, ймовірно, впаде
    direction = "DOWN"

confidence = abs(predicted_value - 0.5) * 2  # Від 0 до 1
```

## Навчання моделі

### Процес навчання

1. **Завантаження історичних даних**
   - CSV файли з історичними цінами криптовалют
   - Дані з Binance API за різні періоди

2. **Генерація послідовностей**
   ```python
   # Для кожної точки даних створюємо:
   # X: попередні 30 точок
   # y: чи зросла ціна через N днів (0 або 1)
   ```

3. **Розділення даних**
   ```python
   # 80% - тренувальні дані
   # 20% - тестові дані
   X_train, X_test, y_train, y_test = train_test_split(
       X, y, test_size=0.2, shuffle=False
   )
   ```

4. **Компіляція моделі**
   ```python
   model.compile(
       optimizer='adam',              # Оптимізатор Adam
       loss='binary_crossentropy',    # Функція втрат для бінарної класифікації
       metrics=['accuracy']           # Метрика точності
   )
   ```

5. **Навчання**
   ```python
   history = model.fit(
       X_train, y_train,
       epochs=20,                     # 20 епох навчання
       batch_size=32,                 # 32 приклади за раз
       validation_data=(X_test, y_test)
   )
   ```

### Метрики якості

- **Accuracy (Точність)**: відсоток правильних прогнозів
- **Loss (Втрати)**: наскільки модель помиляється
- **Validation Accuracy**: точність на тестових даних

## Як LSTM працює з часовими рядами

### Чому LSTM?

1. **Пам'ять про минуле**
   - LSTM запам'ятовує важливі патерни з попередніх даних
   - Може виявляти тренди та цикли

2. **Вирішення проблеми зникаючого градієнта**
   - Звичайні RNN погано працюють з довгими послідовностями
   - LSTM використовує "ворота" для контролю інформації

3. **Селективна пам'ять**
   - **Forget Gate**: що забути з попередньої пам'яті
   - **Input Gate**: яку нову інформацію зберегти
   - **Output Gate**: що вивести на основі пам'яті

### Приклад роботи

```
Вхідні дані (30 точок):
День 1: Open=50000, High=51000, Low=49500, Close=50500, Volume=1M
День 2: Open=50500, High=52000, Low=50000, Close=51500, Volume=1.2M
...
День 30: Open=55000, High=56000, Low=54500, Close=55500, Volume=1.5M

LSTM аналізує:
1. Загальний тренд: ціна зростає
2. Волатильність: різниця між high і low
3. Об'єм торгів: збільшується
4. Патерни: циклічні коливання

Прогноз: 0.75 (75% ймовірність зростання)
```

## Оптимізації

### 1. Dropout (0.2)
- Запобігає перенавчанню
- Модель краще узагальнює на нових даних

### 2. MinMaxScaler
- Нормалізує дані в діапазон [0, 1]
- Прискорює навчання
- Покращує стабільність

### 3. Window Size (30)
- Оптимальний баланс між контекстом і швидкістю
- Достатньо даних для виявлення патернів
- Не занадто довго для обробки

### 4. Batch Size (32)
- Баланс між швидкістю і стабільністю навчання
- Ефективне використання пам'яті

## Обмеження та покращення

### Поточні обмеження:

1. **Бінарна класифікація**
   - Тільки "вгору" або "вниз"
   - Не показує величину зміни

2. **Фіксоване вікно**
   - Завжди 30 точок
   - Не адаптується до різних ситуацій

3. **Обмежені ознаки**
   - Тільки базові дані про ціну
   - Немає зовнішніх факторів (новини, настрої)

### Можливі покращення:

1. **Регресія замість класифікації**
   ```python
   Dense(1, activation='linear')  # Прогноз конкретної ціни
   ```

2. **Додаткові ознаки**
   - Технічні індикатори (RSI, MACD, Bollinger Bands)
   - Дані з соціальних мереж
   - Макроекономічні показники

3. **Attention механізм**
   - Фокусування на найважливіших частинах послідовності
   - Покращена інтерпретованість

4. **Ensemble моделі**
   - Комбінація кількох моделей
   - Більша надійність прогнозів

5. **Динамічне вікно**
   - Адаптивний розмір вікна
   - Різні часові масштаби

## Використання в продакшені

### API Endpoint

```bash
POST http://localhost:8000/predict
Content-Type: application/json

{
  "symbol": "BTCUSDT",
  "prices": [
    {
      "timestamp": 1234567890,
      "open": 50000.0,
      "high": 51000.0,
      "low": 49500.0,
      "close": 50500.0,
      "volume": 1000000.0,
      "trades": 5000
    },
    // ... ще 29+ записів
  ]
}
```

### Відповідь

```json
{
  "prediction": {
    "willRise": 0.75,
    "currencyPair": {
      "name": "BTCUSDT"
    }
  }
}
```

### Потік даних

```
Frontend (React)
    ↓
Backend (Node.js/Express)
    ↓ HTTP запит до Binance API
Binance API (історичні дані)
    ↓ 30+ точок даних
Backend
    ↓ HTTP POST до Python API
Python API (FastAPI)
    ↓ Підготовка даних
LSTM Model (TensorFlow)
    ↓ Прогноз
Python API
    ↓ JSON відповідь
Backend
    ↓ Форматування
Frontend (відображення)
```

## Висновок

Нейронна мережа використовує LSTM архітектуру для аналізу історичних даних про ціни криптовалют і прогнозування майбутнього руху ціни. Модель навчена на великій кількості історичних даних і може виявляти складні патерни в часових рядах.

Ключові переваги:
- ✅ Автоматичне виявлення патернів
- ✅ Робота з послідовностями даних
- ✅ Адаптація до нових даних
- ✅ Швидкі прогнози в реальному часі

Система постійно може покращуватися через:
- Додавання нових даних для навчання
- Експерименти з архітектурою
- Включення додаткових ознак
- Оптимізація гіперпараметрів


